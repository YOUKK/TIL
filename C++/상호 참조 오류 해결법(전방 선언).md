## 상호 참조 에러 상황
```c++
// A.h
#include "B.h"  // B의 헤더 포함
class A {
    B b;  // B를 직접 멤버 변수로 선언
};
```
```c++
// B.h
#include "A.h"  // A의 헤더 포함
class B {
    A a;  // A를 직접 멤버 변수로 선언
};
```
상호 참조 오류는 컴파일러가 구조체 또는 클래스를 완전히 정의하기 전에 사용하려 하기 때문에 발생한다.
<br><br>
위 같은 경우, A.h에서 B.h를 포함하여 B를 먼저 처리하려 하는데, B.h에서 A.h를 포함하여 A를 먼저 처리하려 하고, 이 과정이 끝없이 반복되는 무한 루프에 빠져 컴파일러가 클래스의 크기를 결정하지 못하고 에러가 발생한다.

## 해결 방법
```c++
// A.h (전방 선언 사용)
class B;  // 전방 선언

class A {
public:
    B* bPtr;  // 포인터만 선언 가능
    void doSomething();
};
```
```c++
// B.h
#include "A.h"  // A.h를 포함해도 문제 없음 (B는 A의 전체 구조를 알 수 있음)

class B {
public:
    A a;  // A의 객체 선언 가능 (A의 전체 구조를 이미 알고 있음)
};
```
```c++
// A.cpp
#include "A.h"
#include "B.h"  // 여기서는 B.h를 포함해도 문제 없음

void A::doSomething() {
    bPtr = new B();  // B의 실제 구조를 알기 때문에 동적 생성 가능!
}
```
A.h에는 전방 선언을 사용해 에러를 막고 실제 기능 구현은 cpp 파일에 #include "B.h"하여 구현한다.

## 추가로 클래스 전방선언의 이점에 대해...
* 전방 선언을 사용하면 참조하려는 헤더파일(클래스)에 변경이 생겨도 재컴파일이 이루어지지 않기 때문에 효율성과 속도를 증진시키고자 사용한다.
* 참고로, 전방 선언을 사용해서는 객체를 생성하거나 정의할 수 없고 단순히 포인터만 전달받을 수 있다.

<br>

---
참고 : https://huchuu.tistory.com/8